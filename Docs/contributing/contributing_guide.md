# üë®‚Äçüíª Guia de Contribui√ß√£o - RhSensoERP API

## üìã √çndice

- [Bem-vindo](#bem-vindo)
- [Configura√ß√£o do Ambiente](#configura√ß√£o-do-ambiente)
- [Padr√µes de C√≥digo](#padr√µes-de-c√≥digo)
- [Fluxo de Desenvolvimento](#fluxo-de-desenvolvimento)
- [Testes](#testes)
- [Code Review](#code-review)
- [Debugging](#debugging)
- [Performance](#performance)

## üéØ Bem-vindo

Este guia est√° baseado no **[Perfil do Desenvolvedor ERP](../perfil_desenvolvedor_erp_api.md)** - documento obrigat√≥rio que define o mindset e padr√µes do projeto.

### **üß† Mindset Obrigat√≥rio**

Antes de come√ßar, leia e internalize:
- ‚úÖ **[perfil_desenvolvedor_erp_api.md](../perfil_desenvolvedor_erp_api.md)**

Voc√™ n√£o √© apenas um codificador. Voc√™ √© um **Arquiteto de Solu√ß√µes .NET** respons√°vel pela qualidade, seguran√ßa e performance da aplica√ß√£o.

### **‚ö° Quick Start para Novos Desenvolvedores**

```bash
# 1. Clone o reposit√≥rio
git clone https://github.com/empresa/rhsensoerp-api.git
cd rhsensoerp-api

# 2. Configure seu ambiente
./scripts/setup-dev-environment.sh

# 3. Configure secrets (obrigat√≥rio)
cd Src/API
dotnet user-secrets set "ConnectionStrings:Default" "SUA_CONNECTION_STRING"

# 4. Execute testes para validar setup
dotnet test

# 5. Execute a aplica√ß√£o
dotnet run --project Src/API

# 6. Acesse https://localhost:57148/swagger
```

## üõ†Ô∏è Configura√ß√£o do Ambiente

### **1. Pr√©-requisitos Obrigat√≥rios**

| Ferramenta | Vers√£o | Download | Configura√ß√£o |
|------------|--------|----------|--------------|
| **.NET SDK** | 8.0+ | [Download](https://dotnet.microsoft.com/download) | `dotnet --version` |
| **Visual Studio** | 2022 17.8+ | [Download](https://visualstudio.microsoft.com/) | Workload: ASP.NET |
| **SQL Server** | 2019+ | [Download](https://www.microsoft.com/sql-server) | LocalDB ou Express |
| **Git** | 2.30+ | [Download](https://git-scm.com/) | Configurar nome e email |

### **2. Configura√ß√£o do IDE**

#### **Visual Studio 2022**

```xml
<!-- .editorconfig (j√° existe no projeto) -->
root = true

[*.cs]
# Usar tabs de 4 espa√ßos
indent_style = space
indent_size = 4

# Quebras de linha
end_of_line = crlf
insert_final_newline = true

# Estilo de c√≥digo
dotnet_style_qualification_for_field = false:suggestion
dotnet_style_qualification_for_property = false:suggestion
csharp_new_line_before_open_brace = all
csharp_new_line_before_else = true
```

#### **Extens√µes Recomendadas**

- ‚úÖ **SonarLint**: An√°lise de c√≥digo em tempo real
- ‚úÖ **CodeMaid**: Limpeza autom√°tica de c√≥digo
- ‚úÖ **Roslynator**: Refactoring avan√ßado
- ‚úÖ **GitLens**: Git integrado
- ‚úÖ **REST Client**: Teste de APIs

#### **VS Code (Alternativo)**

```json
// .vscode/settings.json
{
    "dotnet.server.useOmnisharp": false,
    "omnisharp.enableRoslynAnalyzers": true,
    "editor.formatOnSave": true,
    "editor.codeActionsOnSave": {
        "source.organizeImports": true
    },
    "files.exclude": {
        "**/bin": true,
        "**/obj": true
    }
}
```

### **3. Configura√ß√£o do Banco Local**

```bash
# Op√ß√£o 1: SQL Server LocalDB (Recomendado para dev)
sqllocaldb create MSSQLLocalDB
sqllocaldb start MSSQLLocalDB

# Connection String
Server=(localdb)\MSSQLLocalDB;Database=bd_rhu_copenor;Integrated Security=true;

# Op√ß√£o 2: SQL Server Express
# Connection String
Server=localhost\SQLEXPRESS;Database=bd_rhu_copenor;Integrated Security=true;

# Op√ß√£o 3: Docker (se preferir)
docker run -e "ACCEPT_EULA=Y" -e "SA_PASSWORD=YourPassword123" \
  -p 1433:1433 --name sqlserver \
  -d mcr.microsoft.com/mssql/server:2022-latest
```

### **4. Scripts de Setup Automatizado**

```bash
#!/bin/bash
# scripts/setup-dev-environment.sh

echo "üöÄ Configurando ambiente de desenvolvimento..."

# Verificar pr√©-requisitos
check_prerequisite() {
    if ! command -v $1 &> /dev/null; then
        echo "‚ùå $1 n√£o encontrado. Instale antes de continuar."
        exit 1
    fi
    echo "‚úÖ $1 encontrado"
}

check_prerequisite "dotnet"
check_prerequisite "git"
check_prerequisite "sqlcmd"

# Restaurar depend√™ncias
echo "üì¶ Restaurando depend√™ncias..."
dotnet restore

# Configurar User Secrets template
echo "üîê Configurando User Secrets..."
cd Src/API

if [ ! -f "secrets.template.json" ]; then
cat > secrets.template.json << EOF
{
  "ConnectionStrings": {
    "Default": "SUBSTITUA_PELA_SUA_CONNECTION_STRING"
  },
  "Jwt": {
    "SecretKey": "MinhaChaveSecretaParaDev123456789AbCdEf",
    "Issuer": "RhSensoERP-Dev",
    "Audience": "RhSensoERP-Dev-Clients",
    "AccessTokenMinutes": 60
  }
}
EOF
fi

echo "üìã PR√ìXIMOS PASSOS:"
echo "1. Configure sua connection string:"
echo "   dotnet user-secrets set \"ConnectionStrings:Default\" \"SUA_CONNECTION_STRING\""
echo "2. Execute os testes: dotnet test"
echo "3. Execute a aplica√ß√£o: dotnet run --project Src/API"
echo ""
echo "üéØ Leia obrigatoriamente: perfil_desenvolvedor_erp_api.md"
```

## üé® Padr√µes de C√≥digo

### **1. Conven√ß√µes de Nomenclatura**

```csharp
// ‚úÖ CORRETO
public class UserService : IUserService
{
    private readonly ILogger<UserService> _logger;
    private readonly IRepository<User> _userRepository;
    
    public async Task<UserDto> GetUserAsync(string cdUsuario, CancellationToken ct)
    {
        // Implementa√ß√£o
    }
}

// ‚ùå INCORRETO
public class userservice : iuserservice 
{
    public ILogger logger;
    public IRepository<User> userRepo;
    
    public UserDto GetUser(string cd_usuario)
    {
        // Implementa√ß√£o
    }
}
```

### **2. Estrutura de Classes**

```csharp
// Template obrigat√≥rio para Controllers
[ApiController]
[Route("api/v1/[controller]")]
[Produces("application/json")]
public class ExemploController : ControllerBase
{
    private readonly IExemploService _exemploService;
    private readonly ILogger<ExemploController> _logger;

    public ExemploController(IExemploService exemploService, ILogger<ExemploController> logger)
    {
        _exemploService = exemploService;
        _logger = logger;
    }

    /// <summary>
    /// Descri√ß√£o clara do endpoint
    /// </summary>
    /// <param name="request">Par√¢metros de entrada</param>
    /// <param name="ct">Token de cancelamento</param>
    /// <returns>Resposta tipada</returns>
    [HttpPost]
    [ProducesResponseType(typeof(ApiResponse<ExemploResponseDto>), 200)]
    [ProducesResponseType(typeof(ApiResponse<object>), 400)]
    public async Task<ActionResult<ApiResponse<ExemploResponseDto>>> Action(
        [FromBody] ExemploRequestDto request,
        CancellationToken ct)
    {
        try
        {
            var result = await _exemploService.ExecuteAsync(request, ct);
            return Ok(ApiResponse<ExemploResponseDto>.Ok(result));
        }
        catch (ValidationException ex)
        {
            return BadRequest(ApiResponse<object>.Fail(ex.Message));
        }
    }
}
```

### **3. DTOs e Records**

```csharp
// ‚úÖ Use records para DTOs (imut√°veis)
public record CreateUserRequestDto(
    string CdUsuario,
    string DcUsuario,
    string Email,
    char TpUsuario = 'U');

public record UserResponseDto(
    string CdUsuario,
    string DcUsuario,
    string Email,
    bool Active,
    DateTime CreatedAt);

// ‚úÖ Validadores obrigat√≥rios
public class CreateUserRequestValidator : AbstractValidator<CreateUserRequestDto>
{
    public CreateUserRequestValidator()
    {
        RuleFor(x => x.CdUsuario)
            .NotEmpty().WithMessage("C√≥digo do usu√°rio √© obrigat√≥rio")
            .Length(1, 30).WithMessage("C√≥digo deve ter entre 1 e 30 caracteres");
            
        RuleFor(x => x.Email)
            .EmailAddress().When(x => !string.IsNullOrEmpty(x.Email))
            .WithMessage("Email deve ser v√°lido");
    }
}
```

### **4. Services e Use Cases**

```csharp
// ‚úÖ Interface no Application
public interface IUserManagementService
{
    Task<UserResponseDto> CreateUserAsync(CreateUserRequestDto request, CancellationToken ct);
    Task<UserResponseDto> GetUserAsync(string cdUsuario, CancellationToken ct);
    Task<bool> DeactivateUserAsync(string cdUsuario, CancellationToken ct);
}

// ‚úÖ Implementa√ß√£o no Infrastructure
public class UserManagementService : IUserManagementService
{
    private readonly IRepository<User> _userRepository;
    private readonly IUnitOfWork _unitOfWork;
    private readonly ILogger<UserManagementService> _logger;

    public UserManagementService(
        IRepository<User> userRepository,
        IUnitOfWork unitOfWork,
        ILogger<UserManagementService> logger)
    {
        _userRepository = userRepository;
        _unitOfWork = unitOfWork;
        _logger = logger;
    }

    public async Task<UserResponseDto> CreateUserAsync(CreateUserRequestDto request, CancellationToken ct)
    {
        _logger.LogInformation("Criando usu√°rio {CdUsuario}", request.CdUsuario);
        
        // 1. Validar se usu√°rio j√° existe
        var existingUser = await _userRepository
            .FirstOrDefaultAsync(u => u.CdUsuario == request.CdUsuario, ct);
            
        if (existingUser != null)
            throw new DomainException($"Usu√°rio {request.CdUsuario} j√° existe");

        // 2. Criar entidade
        var user = new User
        {
            CdUsuario = request.CdUsuario,
            DcUsuario = request.DcUsuario,
            EmailUsuario = request.Email,
            TpUsuario = request.TpUsuario,
            FlAtivo = 'S'
        };

        // 3. Persistir
        await _userRepository.AddAsync(user, ct);
        await _unitOfWork.SaveChangesAsync(ct);

        _logger.LogInformation("Usu√°rio {CdUsuario} criado com sucesso", user.CdUsuario);

        // 4. Retornar DTO
        return new UserResponseDto(
            user.CdUsuario,
            user.DcUsuario,
            user.EmailUsuario ?? string.Empty,
            user.Active,
            user.CreatedAt);
    }
}
```

## üîÑ Fluxo de Desenvolvimento

### **1. GitFlow Simplificado**

```mermaid
gitgraph
    commit id: "Initial"
    branch develop
    checkout develop
    commit id: "Setup"
    
    branch feature/auth-jwt
    checkout feature/auth-jwt
    commit id: "Add JWT"
    commit id: "Add tests"
    
    checkout develop
    merge feature/auth-jwt
    commit id: "Merge feature"
    
    checkout main
    merge develop
    commit id: "Release v1.0"
```

### **2. Comandos Git Essenciais**

```bash
# 1. Iniciar nova feature
git checkout develop
git pull origin develop
git checkout -b feature/nova-funcionalidade

# 2. Durante desenvolvimento
git add .
git commit -m "feat: adiciona endpoint de usu√°rios"

# 3. Sync com develop
git checkout develop
git pull origin develop
git checkout feature/nova-funcionalidade
git rebase develop

# 4. Push e PR
git push origin feature/nova-funcionalidade
# Criar Pull Request via GitHub/Azure DevOps

# 5. Ap√≥s merge, limpeza
git checkout develop
git pull origin develop
git branch -d feature/nova-funcionalidade
```

### **3. Conventional Commits (Obrigat√≥rio)**

```bash
# Tipos permitidos
feat:     # Nova funcionalidade
fix:      # Corre√ß√£o de bug
docs:     # Documenta√ß√£o
style:    # Formata√ß√£o
refactor: # Refatora√ß√£o
test:     # Testes
chore:    # Manuten√ß√£o

# Exemplos
git commit -m "feat: adiciona endpoint de autentica√ß√£o JWT"
git commit -m "fix: corrige valida√ß√£o de senha vazia"
git commit -m "docs: atualiza README com configura√ß√£o"
git commit -m "test: adiciona testes unit√°rios para UserService"
git commit -m "refactor: extrai l√≥gica de valida√ß√£o para classe espec√≠fica"
```

### **4. Processo de Feature**

#### **Fase 1: Planejamento**
- [ ] Definir requisitos funcionais
- [ ] Identificar impactos arquiteturais
- [ ] Estimar esfor√ßo
- [ ] Definir crit√©rios de aceite

#### **Fase 2: Desenvolvimento**
```bash
# 1. Criar branch
git checkout -b feature/nome-da-feature

# 2. TDD (quando aplic√°vel)
# Escrever testes ANTES da implementa√ß√£o
dotnet test --filter "TestName" # Deve falhar

# 3. Implementar
# Fazer testes passarem

# 4. Refatorar
# Melhorar c√≥digo mantendo testes verdes
```

#### **Fase 3: Finaliza√ß√£o**
- [ ] Todos os testes passando
- [ ] Code coverage adequado
- [ ] Documenta√ß√£o atualizada
- [ ] Auto-review completo
- [ ] PR criado com template

## üß™ Testes

### **1. Pir√¢mide de Testes**

```
        /\
       /  \
      / UI \     ‚Üê Poucos (E2E)
     /______\
    /        \
   / Integration \  ‚Üê Moderados
  /______________\
 /                \
/ Unit Tests       \ ‚Üê Muitos (R√°pidos)
/__________________\
```

### **2. Estrutura de Testes**

```csharp
// ‚úÖ Template para testes unit√°rios
namespace RhSensoERP.Tests.Unit.Services
{
    public class UserManagementServiceTests
    {
        private readonly Mock<IRepository<User>> _userRepositoryMock;
        private readonly Mock<IUnitOfWork> _unitOfWorkMock;
        private readonly Mock<ILogger<UserManagementService>> _loggerMock;
        private readonly UserManagementService _service;

        public UserManagementServiceTests()
        {
            _userRepositoryMock = new Mock<IRepository<User>>();
            _unitOfWorkMock = new Mock<IUnitOfWork>();
            _loggerMock = new Mock<ILogger<UserManagementService>>();
            
            _service = new UserManagementService(
                _userRepositoryMock.Object,
                _unitOfWorkMock.Object,
                _loggerMock.Object);
        }

        [Fact]
        public async Task CreateUserAsync_WithValidData_ShouldCreateUser()
        {
            // Arrange
            var request = new CreateUserRequestDto("test", "Test User", "test@test.com");
            _userRepositoryMock
                .Setup(x => x.FirstOrDefaultAsync(It.IsAny<Expression<Func<User, bool>>>(), It.IsAny<CancellationToken>()))
                .ReturnsAsync((User?)null);

            // Act
            var result = await _service.CreateUserAsync(request, CancellationToken.None);

            // Assert
            result.Should().NotBeNull();
            result.CdUsuario.Should().Be("test");
            _userRepositoryMock.Verify(x => x.AddAsync(It.IsAny<User>(), It.IsAny<CancellationToken>()), Times.Once);
            _unitOfWorkMock.Verify(x => x.SaveChangesAsync(It.IsAny<CancellationToken>()), Times.Once);
        }

        [Fact]
        public async Task CreateUserAsync_WithExistingUser_ShouldThrowDomainException()
        {
            // Arrange
            var request = new CreateUserRequestDto("existing", "Existing User", "existing@test.com");
            var existingUser = new User { CdUsuario = "existing" };
            
            _userRepositoryMock
                .Setup(x => x.FirstOrDefaultAsync(It.IsAny<Expression<Func<User, bool>>>(), It.IsAny<CancellationToken>()))
                .ReturnsAsync(existingUser);

            // Act & Assert
            var act = async () => await _service.CreateUserAsync(request, CancellationToken.None);
            await act.Should().ThrowAsync<DomainException>()
                .WithMessage("*j√° existe*");
        }
    }
}
```

### **3. Testes de Integra√ß√£o**

```csharp
// ‚úÖ Template para testes de integra√ß√£o
public class AuthControllerIntegrationTests : IClassFixture<CustomWebApplicationFactory>
{
    private readonly CustomWebApplicationFactory _factory;
    private readonly HttpClient _client;

    public AuthControllerIntegrationTests(CustomWebApplicationFactory factory)
    {
        _factory = factory;
        _client = factory.CreateClient();
    }

    [Fact]
    public async Task Login_WithValidCredentials_ShouldReturnToken()
    {
        // Arrange
        var request = new LoginRequestDto("admin", "123456");

        // Act
        var response = await _client.PostAsJsonAsync("/api/v1/auth/login", request);

        // Assert
        response.StatusCode.Should().Be(HttpStatusCode.OK);
        
        var content = await response.Content.ReadFromJsonAsync<ApiResponse<LoginResponseDto>>();
        content!.Success.Should().BeTrue();
        content.Data!.AccessToken.Should().NotBeNullOrEmpty();
    }
}
```

### **4. Comandos de Teste**

```bash
# Executar todos os testes
dotnet test

# Testes com cobertura
dotnet test --collect:"XPlat Code Coverage"

# Testes espec√≠ficos
dotnet test --filter "UserManagementServiceTests"

# Testes em paralelo
dotnet test --parallel

# Output detalhado
dotnet test --verbosity normal

# Apenas testes unit√°rios
dotnet test Tests/RhSensoERP.Tests.Unit/

# Apenas testes de integra√ß√£o
dotnet test Tests/RhSensoERP.Tests.Integration/

# Excluir testes de banco (se conex√£o indispon√≠vel)
dotnet test --filter "FullyQualifiedName!~DatabaseTests"
```

## üë• Code Review

### **1. Template de Pull Request**

```markdown
## üìù Descri√ß√£o

Breve descri√ß√£o das mudan√ßas realizadas.

## üéØ Tipo de Mudan√ßa

- [ ] üêõ Bug fix
- [ ] ‚ú® Nova feature
- [ ] üí• Breaking change
- [ ] üìö Documenta√ß√£o
- [ ] üé® Melhoria de c√≥digo
- [ ] ‚ö° Performance
- [ ] üß™ Testes

## üß™ Testes

- [ ] Testes unit√°rios adicionados/atualizados
- [ ] Testes de integra√ß√£o adicionados/atualizados
- [ ] Todos os testes est√£o passando
- [ ] Code coverage mantido/melhorado

## üìã Checklist

- [ ] C√≥digo segue os padr√µes do [perfil do desenvolvedor](../perfil_desenvolvedor_erp_api.md)
- [ ] Documenta√ß√£o atualizada (se necess√°rio)
- [ ] N√£o h√° TODOs ou FIXMEs no c√≥digo
- [ ] Performance considerada
- [ ] Seguran√ßa revisada
- [ ] Logs apropriados adicionados

## üîó Issues Relacionadas

Fixes #123
Related to #456

## üì∏ Screenshots (se aplic√°vel)

[Adicionar screenshots se houver mudan√ßas na UI]

## üìù Notas Adicionais

Informa√ß√µes adicionais para os revisores.
```

### **2. Checklist do Revisor**

#### **Arquitetura e Design**
- [ ] ‚úÖ Segue Clean Architecture
- [ ] ‚úÖ Responsabilidades bem definidas
- [ ] ‚úÖ Padr√µes do projeto seguidos
- [ ] ‚úÖ N√£o h√° viola√ß√£o de depend√™ncias

#### **C√≥digo**
- [ ] ‚úÖ Nomenclatura clara e consistente
- [ ] ‚úÖ Fun√ß√µes pequenas e focadas
- [ ] ‚úÖ Sem duplica√ß√£o de c√≥digo
- [ ] ‚úÖ Tratamento adequado de erros

#### **Seguran√ßa**
- [ ] ‚úÖ Valida√ß√£o de entrada
- [ ] ‚úÖ Autoriza√ß√£o adequada
- [ ] ‚úÖ N√£o exposi√ß√£o de dados sens√≠veis
- [ ] ‚úÖ Logs de seguran√ßa implementados

#### **Performance**
- [ ] ‚úÖ Queries otimizadas
- [ ] ‚úÖ Uso adequado de async/await
- [ ] ‚úÖ Sem vazamentos de mem√≥ria
- [ ] ‚úÖ Cache considerado (se aplic√°vel)

#### **Testes**
- [ ] ‚úÖ Cobertura adequada
- [ ] ‚úÖ Casos edge testados
- [ ] ‚úÖ Mocks apropriados
- [ ] ‚úÖ Testes r√°pidos e isolados

### **3. Coment√°rios de Code Review**

```csharp
// ‚ùå COMENT√ÅRIO RUIM
// Este c√≥digo est√° errado

// ‚úÖ COMENT√ÅRIO BOM
// Sugest√£o: Use repository pattern aqui para melhor testabilidade
// Exemplo:
// var user = await _userRepository.GetByIdAsync(id, ct);

// ‚úÖ COMENT√ÅRIO CONSTRUTIVO
// Nitpick: Considere extrair esta l√≥gica para um m√©todo privado 
// para melhorar a legibilidade. N√£o √© bloqueante.

// ‚úÖ COMENT√ÅRIO DE SEGURAN√áA
// Cr√≠tico: Esta query √© vulner√°vel a SQL Injection. 
// Use par√¢metros: cmd.Parameters.AddWithValue("@id", id)
```

## üêõ Debugging

### **1. Setup de Debug**

#### **Visual Studio**
```json
// launchSettings.json - Configura√ß√£o de debug
{
  "profiles": {
    "RhSensoERP.API": {
      "commandName": "Project",
      "launchBrowser": true,
      "launchUrl": "swagger",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development",
        "ASPNETCORE_URLS": "https://localhost:57148;http://localhost:57149"
      }
    },
    "Docker": {
      "commandName": "Docker",
      "launchBrowser": true,
      "launchUrl": "{Scheme}://{ServiceHost}:{ServicePort}/swagger"
    }
  }
}
```

#### **VS Code**
```json
// .vscode/launch.json
{
    "version": "0.2.0",
    "configurations": [
        {
            "name": ".NET Core Launch (web)",
            "type": "coreclr",
            "request": "launch",
            "preLaunchTask": "build",
            "program": "${workspaceFolder}/Src/API/bin/Debug/net8.0/RhSensoERP.API.dll",
            "args": [],
            "cwd": "${workspaceFolder}/Src/API",
            "stopAtEntry": false,
            "serverReadyAction": {
                "action": "openExternally",
                "pattern": "\\bNow listening on:\\s+(https?://\\S+)"
            },
            "env": {
                "ASPNETCORE_ENVIRONMENT": "Development"
            }
        }
    ]
}
```

### **2. Debugging de Problemas Comuns**

#### **Problema: JWT n√£o funciona**
```csharp
// Debug: Verificar configura√ß√£o JWT
public class JwtDebugController : ControllerBase
{
    [HttpGet("debug/jwt-config")]
    public IActionResult GetJwtConfig([FromServices] IOptions<JwtOptions> jwtOptions)
    {
        var jwt = jwtOptions.Value;
        return Ok(new
        {
            Issuer = jwt.Issuer,
            Audience = jwt.Audience,
            HasSecretKey = !string.IsNullOrEmpty(jwt.SecretKey),
            HasPublicKey = !string.IsNullOrEmpty(jwt.PublicKeyPem),
            AccessTokenMinutes = jwt.AccessTokenMinutes
        });
    }
}
```

#### **Problema: Entity Framework n√£o carrega dados**
```csharp
// Debug: Verificar queries EF
protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
{
    optionsBuilder.LogTo(Console.WriteLine, LogLevel.Information);
    // ou
    optionsBuilder.EnableSensitiveDataLogging(); // APENAS EM DESENVOLVIMENTO
}
```

#### **Problema: Dependency Injection**
```csharp
// Debug: Verificar servi√ßos registrados
public class DiagnosticsController : ControllerBase
{
    [HttpGet("debug/services")]
    public IActionResult GetRegisteredServices([FromServices] IServiceProvider serviceProvider)
    {
        // APENAS EM DESENVOLVIMENTO
        var services = serviceProvider.GetService<IServiceCollection>();
        return Ok(services?.Select(s => new { s.ServiceType.Name, s.Lifetime }));
    }
}
```

### **3. Logging para Debug**

```csharp
// ‚úÖ Logs estruturados para debugging
public class UserService
{
    private readonly ILogger<UserService> _logger;

    public async Task<User> GetUserAsync(string cdUsuario)
    {
        using var scope = _logger.BeginScope(new Dictionary<string, object>
        {
            ["UserId"] = cdUsuario,
            ["Method"] = nameof(GetUserAsync),
            ["Timestamp"] = DateTime.UtcNow
        });

        _logger.LogDebug("Iniciando busca de usu√°rio {CdUsuario}", cdUsuario);

        try
        {
            var user = await _userRepository.GetByCdUsuarioAsync(cdUsuario);
            
            if (user == null)
            {
                _logger.LogWarning("Usu√°rio {CdUsuario} n√£o encontrado", cdUsuario);
                return null;
            }

            _logger.LogDebug("Usu√°rio {CdUsuario} encontrado com sucesso", cdUsuario);
            return user;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Erro ao buscar usu√°rio {CdUsuario}", cdUsuario);
            throw;
        }
    }
}
```

## ‚ö° Performance

### **1. Profiling e Monitoramento**

```csharp
// ‚úÖ Middleware para medir performance
public class PerformanceMiddleware
{
    private readonly RequestDelegate _next;
    private readonly ILogger<PerformanceMiddleware> _logger;

    public PerformanceMiddleware(RequestDelegate next, ILogger<PerformanceMiddleware> logger)
    {
        _next = next;
        _logger = logger;
    }

    public async Task InvokeAsync(HttpContext context)
    {
        var stopwatch = Stopwatch.StartNew();
        
        await _next(context);
        
        stopwatch.Stop();
        
        if (stopwatch.ElapsedMilliseconds > 1000) // Log requests > 1s
        {
            _logger.LogWarning("Slow request: {Method} {Path} took {ElapsedMs}ms",
                context.Request.Method,
                context.Request.Path,
                stopwatch.ElapsedMilliseconds);
        }
    }
}
```

### **2. Otimiza√ß√µes de Banco**

```csharp
// ‚úÖ Queries otimizadas
public class UserRepository
{
    // AsNoTracking para read-only queries
    public async Task<List<UserDto>> GetActiveUsersAsync()
    {
        return await _context.Users
            .AsNoTracking()
            .Where(u => u.FlAtivo == 'S')
            .Select(u => new UserDto(u.CdUsuario, u.DcUsuario)) // Projete apenas campos necess√°rios
            .ToListAsync();
    }

    // Include expl√≠cito para evitar N+1
    public async Task<User> GetUserWithGroupsAsync(string cdUsuario)
    {
        return await _context.Users
            .Include(u => u.UserGroups)
                .ThenInclude(ug => ug.GrupoDeUsuario)
            .FirstOrDefaultAsync(u => u.CdUsuario == cdUsuario);
    }

    // Pagina√ß√£o eficiente
    public async Task<PagedResult<User>> GetUsersPagedAsync(int page, int pageSize)
    {
        var query = _context.Users.AsNoTracking();
        
        var total = await query.CountAsync();
        
        var items = await query
            .OrderBy(u => u.CdUsuario)
            .Skip((page - 1) * pageSize)
            .Take(pageSize)
            .ToListAsync();

        return new PagedResult<User>
        {
            Items = items,
            Page = page,
            PageSize = pageSize,
            TotalCount = total
        };
    }
}
```

### **3. Caching**

```csharp
// ‚úÖ Cache distribu√≠do (Redis) para dados frequentemente acessados
public class CachedUserService : IUserService
{
    private readonly IUserService _userService;
    private readonly IDistributedCache _cache;
    private readonly ILogger<CachedUserService> _logger;

    public async Task<UserPermissions> GetUserPermissionsAsync(string cdUsuario, CancellationToken ct)
    {
        var cacheKey = $"user:permissions:{cdUsuario}";
        
        var cachedData = await _cache.GetStringAsync(cacheKey, ct);
        if (cachedData != null)
        {
            _logger.LogDebug("Cache hit for user permissions {CdUsuario}", cdUsuario);
            return JsonSerializer.Deserialize<UserPermissions>(cachedData)!;
        }

        var permissions = await _userService.GetUserPermissionsAsync(cdUsuario, ct);
        
        var serialized = JsonSerializer.Serialize(permissions);
        var options = new DistributedCacheEntryOptions
        {
            AbsoluteExpirationRelativeToNow = TimeSpan.FromMinutes(30)
        };
        
        await _cache.SetStringAsync(cacheKey, serialized, options, ct);
        
        _logger.LogDebug("Cache miss for user permissions {CdUsuario}, data cached", cdUsuario);
        return permissions;
    }
}
```

### **4. Ferramentas de Performance**

```bash
# BenchmarkDotNet para micro-benchmarks
dotnet add package BenchmarkDotNet

# PerfView para profiling detalhado (Windows)
# https://github.com/Microsoft/perfview

# dotMemory para an√°lise de mem√≥ria (JetBrains)
# https://www.jetbrains.com/dotmemory/

# Application Insights para monitoramento em produ√ß√£o
dotnet add package Microsoft.ApplicationInsights.AspNetCore
```

## üìö Recursos e Refer√™ncias

### **Documenta√ß√£o Interna**
- üìñ **[Perfil do Desenvolvedor](../perfil_desenvolvedor_erp_api.md)** - LEITURA OBRIGAT√ìRIA
- üèóÔ∏è **[Arquitetura](../docs/architecture/overview.md)** - Overview da Clean Architecture
- üîê **[Autentica√ß√£o](../docs/api/authentication.md)** - Sistema JWT e Legacy
- ‚öôÔ∏è **[Configura√ß√£o](../docs/getting-started/configuration.md)** - Setup completo

### **Ferramentas Essenciais**
- üîç **[Swagger UI](https://localhost:57148/swagger)** - Documenta√ß√£o da API
- üìä **[Health Checks](https://localhost:57148/health)** - Status da aplica√ß√£o
- üß™ **[Testes via API](https://localhost:57148/api/v1/test/banco)** - Verificar banco

### **Recursos Externos**
- üìö **[Clean Architecture](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html)** - Robert C. Martin
- üéØ **[.NET Guidelines](https://docs.microsoft.com/en-us/dotnet/standard/design-guidelines/)** - Microsoft
- ‚úÖ **[FluentValidation](https://docs.fluentvalidation.net/en/latest/)** - Documenta√ß√£o oficial
- üß™ **[FluentAssertions](https://fluentassertions.com/introduction)** - Sintaxe de testes

### **Comunidade**
- üí¨ **Slack**: #rhsenso-api-dev
- üìß **Email**: dev-team@rhsenso.com
- üé• **Teams**: Reuni√µes de arquitetura (ter√ßas 14h)

## üö® Quando Pedir Ajuda

### **Antes de Pedir**
- [ ] ‚úÖ Li a documenta√ß√£o relevante
- [ ] ‚úÖ Busquei no hist√≥rico do Slack/Teams
- [ ] ‚úÖ Tentei debuggar por pelo menos 30min
- [ ] ‚úÖ Verifiquei logs e stack traces

### **Como Pedir Ajuda Efetivamente**

```markdown
## üêõ Problema

Descri√ß√£o clara e concisa do problema.

## üéØ Objetivo

O que voc√™ est√° tentando alcan√ßar.

## üîÑ Tentativas

1. Tentei X, resultado Y
2. Tentei Z, resultado W

## üíª C√≥digo Relevante

```csharp
// Cole aqui o c√≥digo com problema
```

## üìä Logs/Erros

```
[Stack trace ou mensagens de erro]
```

## üåç Ambiente

- SO: Windows 11 / Ubuntu 22.04
- IDE: Visual Studio 2022 / VS Code
- .NET: 8.0.1
- Banco: SQL Server LocalDB
```

## üéâ Conclus√£o

Lembre-se: **Voc√™ √© um Arquiteto de Solu√ß√µes .NET**, n√£o apenas um codificador. Cada linha de c√≥digo que voc√™ escreve impacta:

- ‚úÖ **Qualidade** do produto
- ‚úÖ **Seguran√ßa** dos dados
- ‚úÖ **Performance** da aplica√ß√£o
- ‚úÖ **Manutenibilidade** do c√≥digo
- ‚úÖ **Experi√™ncia** do usu√°rio

**Pr√≥ximos passos:**
1. üìö Leia o [perfil_desenvolvedor_erp_api.md](../perfil_desenvolvedor_erp_api.md)
2. ‚öôÔ∏è Configure seu ambiente de desenvolvimento
3. üß™ Execute todos os testes
4. üöÄ Comece sua primeira feature

---

üí° **Dica Final**: Quando em d√∫vida, sempre prefira simplicidade e clareza. C√≥digo que funciona hoje e √© mant√≠vel amanh√£ √© melhor que c√≥digo "elegante" que ningu√©m entende.